%{
/*
 * selecção de instruções com postfix
 */
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include "node.h"
#include "postfix.h"
#include "y.tab.h"
#include "minor.h"

#define CMPVAL 1111
#define EXTMAX 100
#define IFMAX 20
#define FORMAX 20

#ifndef U_
#define U_ "_"
#endif

#define TRACE
static void yytrace(NODEPTR_TYPE p, int eruleno, int cost, int bestcost);

extern FILE *yyout;

int ifvec[IFMAX][2]; /* [ { if_end, current_elif }, {...iflvl2...}, ... ] */
int iflvl = -1;

int forvec[FORMAX];
int forlvl = -1;

static char *extvec[EXTMAX];
static int extcnt;

int lbl;

static char *mklbl(int n) {
	static char buf[20];
	sprintf(buf, "%cL%d", n < 0 ? '.' : '_', n);
	return strcpy(malloc(strlen(buf)+1),buf);
}

static char *mkfunc(char *s) {
	static char buf[80];
	strcpy(buf, "_");
	strcat(buf, s);
	return buf;
}

static void strtopf(char *s) {
  while (*s) fprintf(yyout, pfCHAR, (unsigned char)*s++);
}

static void cmp(Node* n, char *op) {
	if (tTYPE(LEFT_CHILD(n)->info) == tSTR) 
		fprintf(yyout, pfSWAP pfCALL pfTRASH pfPUSH pfIMM, "mstrcmp", pfWORD * 2, 0);
	fprintf(yyout, "%s", op);
}

static void var(Node* p) {
	int type = p->info;
	if (p->attrib == VAR) p = LEFT_CHILD(p);
	char* id = LEFT_CHILD(p)->value.s;
	Node *val =  RIGHT_CHILD(p);

	if (type & tFWD) { extvec[extcnt++] = strdup(id); return; }
	if (type & tPUB) fprintf(yyout, pfTEXT pfALIGN pfGLOBL, id, pfOBJ);

	if (type & tCNST)  fprintf(yyout, pfRODATA);
	else if (RIGHT_CHILD(p)->type != nodeNil) fprintf(yyout, pfDATA);
	else {
		fprintf(yyout, pfBSS pfALIGN pfLABEL pfBYTE, id, tTYPE(type) == tINT ? 4 : pfWORD);
		return;
	}
	
	fprintf(yyout, pfALIGN pfLABEL, id);
	if (tTYPE(type) == tINT) fprintf(yyout, pfINTEGER, val->value.i);
	else fprintf(yyout, pfID, mklbl(lbl));
}

static void pubvar(char* id) { fprintf(yyout, pfTEXT pfALIGN pfGLOBL, id, pfOBJ); }
static void bss(char* id, int b) { fprintf(yyout, pfBSS pfALIGN pfLABEL pfBYTE, id, b); }

static int isPUB(Node *n) { return n->info & tPUB ? 1 : CMPVAL; }
static int isInt(Node *n) { return tTYPE(n->info) == tINT ? 1 : CMPVAL; }
static int isStr(Node *n) { return tTYPE(n->info) == tSTR ? 1 : CMPVAL; }
static int leftInt(Node *n) { return tTYPE(LEFT_CHILD(n)->info) == tINT ? 1 : CMPVAL; }
static int leftStr(Node *n) { return tTYPE(LEFT_CHILD(n)->info) == tSTR ? 1 : CMPVAL; }
static int leftZero(Node *n) { return LEFT_CHILD(n)->value.i == 0 ? 1 : CMPVAL; }
%}
%term STMT=';' PRINT='!' ALLOC='#' INDEX='[' SCAN='?' CALL='(' PARAM=','
%term ADD='+' SUB='-' MUL='*' DIV='/' MOD='%' POW='^' 
%term EQ='=' GT='>' LT='<' AND='&' OR='|' NOT='~' 
%include "y.tab.h"
%%
file	: PROGRAM(decls, FUNCTION(END(ID, INT), FARGS(NIL, main)))	1 { fprintf(yyout, pfIMM pfPOP pfLEAVE pfRET, 0); }
file	: MODULE(decls)									1 {}

fvars 	: ARGS(NIL, vardecl)							1 {}
fvars 	: ARGS(fvars, vardecl)							1 {}

main 	: START(mvars, instrs)			1 {}
mvars 	: ARGS(mvars, vardecl)			1 {}
mvars	: NIL							1 { fprintf(yyout, pfTEXT pfALIGN pfGLOBL pfLABEL pfENTER, "_main", pfFUNC, "_main", 0); }
%! declarations

decls	: NIL 											1 {}
decls 	: DECL(decls, decl)								1 {}

decl	: NIL											1 {}
decl 	: FUNCTION(END(ID, INT), FARGS(fvars, eqbody))	1 {}
decl 	: FUNCTION(END(ID, INT), FARGS(NIL, eqbody))	1 {}

decl 	: VAR(NUMBER(ID, int)) 			1 { var(p); }
decl 	: VAR(STRING(ID, str))			1 { var(p); }
decl 	: VAR(ARRAY(ID, arr))			1 { var(p); }

vardecl	: NUMBER(ID, int)				1 { var(p); }
vardecl	: STRING(ID, str)				1 { var(p); }
vardecl	: ARRAY(ID, arr)				1 { var(p); }

int 	: INT							1 {}
int 	: NIL							1 {}

arr 	: NIL							1 {}
arr 	: INTS(INT, ints)				leftZero {}
arr 	: INTS(INT, ints)				2 { fprintf(yyout, pfBYTE, 4*(LEFT_CHILD(p)->value.i - ((int)RIGHT_CHILD(p)->place))); }
ints 	: NIL							1 { fprintf(yyout, pfDATA pfALIGN pfLABEL, mklbl(++lbl)); p->place = 0; }
ints 	: INTS(ints, INT)				1 { fprintf(yyout, pfINTEGER, RIGHT_CHILD(p)->value.i); p->place = LEFT_CHILD(p)->place + 1; }

str		: chars							1 { fprintf(yyout, pfCHAR, 0); }
chars	: CHARS(chars, char)			1 {}
chars 	: NIL							1 { fprintf(yyout, pfRODATA pfALIGN pfLABEL, mklbl(++lbl)); }		

char 	: INT							1 { fprintf(yyout, pfCHAR, (char) p->value.i); }
char 	: CHAR							1 { fprintf(yyout, pfCHAR, (char) p->value.i); }
char 	: STR							1 { strtopf(p->value.s); }

eqbody 	: NIL											1 {}
eqbody 	: body											1 {}

body 	: START(fvars, STMT(instrs, ret))				1 {}
body 	: START(NIL, STMT(instrs, ret))					1 {}

ret 	: RETURN(NIL)									1 {}
ret 	: RETURN(expr)									1 {}
ret 	: NIL											1 {}

instrs 	: NIL											1 { fprintf(yyout, pfTEXT pfALIGN); }
instrs 	: STMT(instrs, instr)							1 {}

%! if elif else
ifcond 	: expr 											1 { ifvec[++iflvl][0] = ++lbl; fprintf(yyout, pfJZ, mklbl(ifvec[iflvl][1] = ++lbl));}
eicond 	: expr											1 { fprintf(yyout, pfJZ, mklbl(ifvec[iflvl][1] = ++lbl)); }
instr 	: FI(THEN(IF(ifcond, ifbody), elifs), else)		1 { fprintf(yyout, pfLABEL, mklbl(ifvec[iflvl][0])); iflvl--; }
elifs 	: ELIF(elifs, IF(eicond, ifbody))				1 {}
elifs 	: NIL											1 {}
else 	: STMT(instrs, loop)							1 {}
else	: NIL											1 {}
ifbody 	: STMT(instrs, loop)							1 { fprintf(yyout, pfJMP pfLABEL, mklbl(ifvec[iflvl][0]), mklbl(ifvec[iflvl][1])); }

%! for loop
instr 	: FOR(UNTIL(fbegin, fcond), STEP(forbody, instr))	1 { fprintf(yyout, pfJMP pfLABEL, mklbl(LEFT_CHILD(LEFT_CHILD(p))->place), mklbl(forvec[forlvl])); forlvl--; }
fbegin	: instr												1 { fprintf(yyout, pfLABEL, mklbl(p->place = ++lbl)); }
fcond	: expr												1 { fprintf(yyout, pfJNZ, mklbl(forvec[++forlvl] = ++lbl)); lbl++; }
forbody	: STMT(instrs, loop)								1 { fprintf(yyout, pfLABEL, mklbl(forvec[forlvl]+1)); }
loop 	: REPEAT											1 { fprintf(yyout, pfJMP, mklbl(forvec[forlvl]+1)); }
loop 	: STOP												1 { fprintf(yyout, pfJMP, mklbl(forvec[forlvl])); }
loop 	: ret												1 {}

instr 	: expr							1 { fprintf(yyout, pfTRASH, 4); }
instr 	: ALLOC(expr, lval)				1 { }
instr 	: PRINT(expr)					leftStr { fprintf(yyout, pfCALL pfTRASH pfPUSH, "_prints", pfWORD); }
instr 	: PRINT(expr)					2 { fprintf(yyout, pfCALL pfTRASH pfPUSH, "_printi", 4); }

lval 	: ID							1 { fprintf(yyout, pfADDR, p->value.s); }
lval 	: INDEX(expr, ID)				1 { fprintf(yyout, pfIMM pfMUL pfADDR pfLOAD pfADD, RIGHT_CHILD(p)->info == tSTR ? 1 : 4, RIGHT_CHILD(p)->value.s); }

lits 	: CHARS(NIL, INT) 				1 { fprintf(yyout, pfIMM, RIGHT_CHILD(p)->value.i); }
lits 	: CHARS(NIL, CHAR) 				1 { fprintf(yyout, pfIMM, RIGHT_CHILD(p)->value.i); }
lits 	: str							2 { fprintf(yyout, pfTEXT pfALIGN pfADDR, mklbl(lbl)); }

expr 	: lits 							1 {}
expr	: lval							1 { fprintf(yyout, (p->attrib == '[' && RIGHT_CHILD(p)->info == tSTR) ? pfLDCHR : pfLOAD); }
expr	: SCAN							1 { fprintf(yyout, pfCALL pfPUSH, "_readi"); }
expr	: ADDR(lval)					1 {}
expr	: DEF(rval, lval)				1 { fprintf(yyout, pfSTORE); }
rval 	: expr							1 { fprintf(yyout, pfDUP); }
expr	: CALL(ID, exprs)				1 {}
exprs 	: PARAM(expr, NIL)				1 {}
exprs	: PARAM(expr, exprs)			1 {}

expr	: ADD(expr, expr)				1 { fprintf(yyout, pfADD); }
expr	: SUB(expr, expr)				1 { fprintf(yyout, pfSUB); }
expr	: MUL(expr, expr)				1 { fprintf(yyout, pfMUL); }
expr	: DIV(expr, expr)				1 { fprintf(yyout, pfDIV); }
expr	: MOD(expr, expr)				1 { fprintf(yyout, pfMOD); }
expr	: POW(expr, expr)				1 { fprintf(yyout, pfCALL pfTRASH pfPUSH, "mpow", 8); }
expr	: EQ(expr, expr)				1 { cmp(p, pfEQ); }
expr	: NE(expr, expr)				1 { cmp(p, pfNE); }
expr	: GE(expr, expr)				1 { cmp(p, pfGE); }
expr	: LE(expr, expr)				1 { cmp(p, pfLE); }
expr	: GT(expr, expr)				1 { cmp(p, pfGT); }
expr	: LT(expr, expr)				1 { cmp(p, pfLT); }
expr	: AND(and,expr)					1 { fprintf(yyout, pfLABEL, mklbl(LEFT_CHILD(p)->place)); }
and		: expr							1 { p->place = ++lbl; fprintf(yyout, pfDUP pfJZ pfTRASH, mklbl(p->place), pfWORD); }
expr	: OR(or,expr)					1 { fprintf(yyout, pfLABEL, mklbl(LEFT_CHILD(p)->place)); }
or		: expr							1 { p->place = ++lbl; fprintf(yyout, pfDUP pfJNZ pfTRASH, mklbl(p->place), pfWORD); }
expr	: NOT(expr)						1 { fprintf(yyout, pfIMM pfEQ, 0); }
expr	: UMINUS(expr)					1 { fprintf(yyout, pfNEG); }


%%
extern char **yynames;
extern int trace, errors, debugNode;
void evaluate(Node *p) {
	int i;

	if (errors) return;
	/* if (trace) */ printNode(p, stdout, yynames);
	if (!yyselect(p) && trace) printf("selection successful\n");

	extvec[extcnt++] = strdup("_prints");
	extvec[extcnt++] = strdup("_printi");
	extvec[extcnt++] = strdup("_readi");
	extvec[extcnt++] = strdup("mpow");
	extvec[extcnt++] = strdup("mstrcmp");

	for (i = 0; i < extcnt; i++) fprintf(yyout, pfEXTRN, extvec[i]);
}

#ifndef NOTRACE
static void yytrace(NODEPTR_TYPE p, int eruleno, int cost, int bestcost)
{
	int op = OP_LABEL(p);
	YYCONST char *tname = yytermname[op] ? yytermname[op] : "?";
	if (debugNode) fprintf(stderr, "0x%p:%s matched %s with cost %d vs. %d\n", p, tname, yystring[eruleno], cost, bestcost);
	if (cost >= MAX_COST && bestcost >= MAX_COST) {
		fprintf(stderr, "0x%p:%s NO MATCH %s with cost %d vs. %d\n", p, tname, yystring[eruleno], cost, bestcost);
		printNode(p, stderr, yynames);
	}
}
#endif
