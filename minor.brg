%{
/*
 * selecção de instruções com postfix
 */
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include "node.h"
#include "postfix.h"
#include "y.tab.h"
#include "minor.h"

#define CMPVAL 1111

#ifndef U_
#define U_ "_"
#endif

#define TRACE
static void yytrace(NODEPTR_TYPE p, int eruleno, int cost, int bestcost);

extern FILE *yyout;

int lbl;

static char *mklbl(int n) {
	static char buf[20];
	sprintf(buf, "%cL%d", n < 0 ? '.' : '_', n);
	return strcpy(malloc(strlen(buf)+1),buf);
}

static char *mkfunc(char *s) {
	static char buf[80];
	strcpy(buf, "_");
	strcat(buf, s);
	return buf;
}

static void strtopf(char *s) {
  while (*s) fprintf(yyout, pfCHAR, (unsigned char)*s++);
}

static void cmp(Node* n, char *op) {
	if (tTYPE(LEFT_CHILD(n)->info) == tSTR) 
		fprintf(yyout, pfSWAP pfCALL pfTRASH pfPUSH pfEXTRN pfIMM, "mstrcmp", pfWORD * 2, "mstrcmp", 0);
	fprintf(yyout, "%s", op);
}

static int isInt(Node *n) { return tTYPE(n->info) == tINT ? 1 : CMPVAL; }
static int isStr(Node *n) { return tTYPE(n->info) == tSTR ? 1 : CMPVAL; }

static int leftInt(Node *n) { return tTYPE(LEFT_CHILD(n)->info) == tINT ? 1 : CMPVAL; }
static int leftStr(Node *n) { return tTYPE(LEFT_CHILD(n)->info) == tSTR ? 1 : CMPVAL; }
%}
%term STMT=';' PRINT='!' ALLOC='#' INDEX='[' SCAN='?' CALL='(' PARAM=','
%term ADD='+' SUB='-' MUL='*' DIV='/' MOD='%' POW='^' 
%term EQ='=' GT='>' LT='<' AND='&' OR='|' NOT='~' 
%include "y.tab.h"
%%
file	: PROGRAM(decls, FUNCTION(END(ID, INT), FARGS(NIL, main)))	1 { fprintf(yyout, pfIMM pfPOP pfLEAVE pfRET, 0); }
file	: MODULE(decls)									1 {}

decls	: NIL 											1 {}
decls 	: DECL(decls, decl)								1 {}

decl 	: VAR(vardecl) 									1 {}
decl 	: FUNCTION(END(ID, INT), FARGS(fvars, eqbody))	1 {}
decl 	: FUNCTION(END(ID, INT), FARGS(NIL, eqbody))	1 {}
decl	: NIL											1 {}

fvars 	: ARGS(NIL, vardecl)							1 {}
fvars 	: ARGS(fvars, vardecl)							1 {}

vardecl : NUMBER(ID, NIL)								1 { fprintf(yyout, pfBSS pfALIGN pfLABEL pfBYTE, LEFT_CHILD(p)->value.s, 4); }
vardecl	: STRING(ID, NIL)								1 { fprintf(yyout, pfBSS pfALIGN pfLABEL pfBYTE, LEFT_CHILD(p)->value.s, pfWORD); }
vardecl	: ARRAY(ID, NIL)								1 {}

vardecl	: NUMBER(ID, INT)								1 { fprintf(yyout, pfDATA pfALIGN pfLABEL pfINTEGER, LEFT_CHILD(p)->value.s, RIGHT_CHILD(p)->value.i); }
vardecl	: STRING(ID, lits)								1 { fprintf(yyout, pfDATA pfALIGN pfLABEL pfID, LEFT_CHILD(p)->value.s, mklbl(lbl)); }
vardecl	: ARRAY(ID, INTS(INT, eqvec))					1 {}

lits 	: CHARS(NIL, INT) 								1 { fprintf(yyout, pfIMM, RIGHT_CHILD(p)->value.i); }
lits 	: CHARS(NIL, CHAR) 								1 { fprintf(yyout, pfIMM, RIGHT_CHILD(p)->value.i); }
lits 	: CHARS(chars, char)							2 { fprintf(yyout, pfCHAR pfTEXT pfADDR, 0, mklbl(lbl)); }
									
chars 	: NIL											1 { fprintf(yyout, pfRODATA pfALIGN pfLABEL, mklbl(++lbl)); }		
chars	: CHARS(chars, char)							1 {}

char 	: INT											1 { fprintf(yyout, pfCHAR, (char) p->value.i); }
char 	: CHAR											1 { fprintf(yyout, pfCHAR, (char) p->value.i); }
char 	: STR											1 { strtopf(p->value.s); }

eqvec	: NIL											1 {}
eqvec 	: ints											1 {}

ints 	: INT											1 {}
%! ints : INT											1 {}
ints 	: INTS(ints, INT)								1 {}
%! ints : INTS(ints, INT)								1 {}

eqbody 	: NIL											1 {}
eqbody 	: body											1 {}

main 	: START(fvars, minstrs)							1 {}
main 	: START(NIL, minstrs)							1 {}

body 	: START(fvars, STMT(instrs, ret))				1 {}
body 	: START(NIL, STMT(instrs, ret))					1 {}

ret 	: RETURN(NIL)									1 {}
ret 	: RETURN(expr)									1 {}
ret 	: NIL											1 {}

loop 	: ret											1 {}
loop 	: REPEAT										1 {}
loop 	: STOP											1 {}

block 	: STMT(instrs, loop)							1 {}

instrs 	: NIL											1 {}
instrs 	: STMT(instrs, instr)							1 {}

minstrs : NIL											1 { fprintf(yyout, pfTEXT pfALIGN pfGLOBL pfLABEL pfENTER, "_main", pfFUNC, "_main", 0); }
minstrs : STMT(minstrs, instr)							1 {}

instr 	: FI(THEN(if, elifs), else)						1 {}
instr 	: FOR(UNTIL(expr, expr), STEP(block, expr))		1 {}
instr 	: expr											1 {}
instr 	: ALLOC(expr, lval)								1 {}
instr 	: PRINT(expr)									leftStr { fprintf(yyout, pfCALL pfTRASH pfPUSH pfEXTRN, "_prints", pfWORD, "_prints"); }
instr 	: PRINT(expr)									leftInt { fprintf(yyout, pfCALL pfTRASH pfPUSH pfEXTRN, "_printi", 4, "_printi"); }

elifs 	: NIL											1 {}
elifs 	: ELIF(elifs, IF(expr, block))					1 {}

else	: NIL											1 {}
else 	: block											1 {}

lval 	: ID											1 { fprintf(yyout, pfADDR, p->value.s); }
lval 	: INDEX(expr, ID)								1 {}

expr 	: lits											1 {}
expr	: lval											1 { fprintf(yyout, pfLOAD); }
expr	: SCAN											1 { fprintf(yyout, pfCALL pfPUSH pfEXTRN, "_readi", "_readi"); }
expr	: ADDR(lval)									1 {}

expr	: ADD(expr, expr)				1 { fprintf(yyout, pfADD); }
expr	: SUB(expr, expr)				1 { fprintf(yyout, pfSUB); }
expr	: MUL(expr, expr)				1 { fprintf(yyout, pfMUL); }
expr	: DIV(expr, expr)				1 { fprintf(yyout, pfDIV); }
expr	: MOD(expr, expr)				1 { fprintf(yyout, pfMOD); }
expr	: POW(expr, expr)				1 { fprintf(yyout, pfCALL pfTRASH pfPUSH pfEXTRN, "mpow", 8, "mpow"); }
expr	: EQ(expr, expr)				1 { cmp(p, pfEQ); }
expr	: NE(expr, expr)				1 { cmp(p, pfNE); }
expr	: GE(expr, expr)				1 { cmp(p, pfGE); }
expr	: LE(expr, expr)				1 { cmp(p, pfLE); }
expr	: GT(expr, expr)				1 { cmp(p, pfGT); }
expr	: LT(expr, expr)				1 { cmp(p, pfLT); }
expr	: AND(and,expr)					1 { fprintf(yyout, pfLABEL, mklbl(LEFT_CHILD(p)->place)); }
and		: expr							1 { p->place = ++lbl; fprintf(yyout, pfDUP pfJZ pfTRASH, mklbl(p->place), pfWORD); }
expr	: OR(or,expr)					1 { fprintf(yyout, pfLABEL, mklbl(LEFT_CHILD(p)->place)); }
or		: expr							1 { p->place = ++lbl; fprintf(yyout, pfDUP pfJNZ pfTRASH, mklbl(p->place), pfWORD); }
expr	: NOT(expr)						1 { fprintf(yyout, pfIMM pfEQ, 0); }
expr	: UMINUS(expr)					1 { fprintf(yyout, pfNEG); }

expr	: DEF(rval, lval)				1 { fprintf(yyout, pfSTORE); }
rval 	: expr							1 { fprintf(yyout, pfDUP); }
expr	: CALL(ID, exprs)				1 {}

exprs 	: PARAM(expr, NIL)								1 {}
exprs	: PARAM(expr, exprs)							1 {}

%%
extern char **yynames;
extern int trace, errors, debugNode;
void evaluate(Node *p) {
	if (errors) return;
	/* if (trace) */ printNode(p, stdout, yynames);
	if (!yyselect(p) && trace) printf("selection successful\n");
}

#ifndef NOTRACE
static void yytrace(NODEPTR_TYPE p, int eruleno, int cost, int bestcost)
{
	int op = OP_LABEL(p);
	YYCONST char *tname = yytermname[op] ? yytermname[op] : "?";
	if (debugNode) fprintf(stderr, "0x%p:%s matched %s with cost %d vs. %d\n", p, tname, yystring[eruleno], cost, bestcost);
	if (cost >= MAX_COST && bestcost >= MAX_COST) {
		fprintf(stderr, "0x%p:%s NO MATCH %s with cost %d vs. %d\n", p, tname, yystring[eruleno], cost, bestcost);
		printNode(p, stderr, yynames);
	}
}
#endif
